import * as bodyParser from 'body-parser';
import { NestFactory } from '@nestjs/core';
import { NestExpressApplication } from '@nestjs/platform-express';
import { AppModule } from './modules/app.module';
import { Logger } from '@nestjs/common';
import { EnvService } from './modules/@global/env/env.service';
import { ENV_SERVICE_TOKEN } from './modules/@global/env/env.constants';
import helmet from 'helmet';

//TODO Implement lock in user (add locked in user identity table)
//TODO return hashed jwt to frontend and make it optional from env add is_jwt_hashed and jwt_hash_secret

// so in frontend when for example a,b,c requests are all sent and lets say b was fastest and got refresh
// immediatly when b refreshes a and c must be cancelled, then filled with new accessToken and resent
// which is implemented in this video
// But I think 2 axios instance will be needed one for refresh route and one fore all other
// https://www.youtube.com/watch?v=nI8PYZNFtac
// and this is code example

NestFactory.create<NestExpressApplication>(AppModule).then(async (app: NestExpressApplication) => {
  const envService = app.get<string, EnvService>(ENV_SERVICE_TOKEN);
  const logger = new Logger('Main logger');

  app.enableCors();
  app.enableShutdownHooks();
  app.set('trust proxy', 1);
  app.use(helmet());
  app.use(bodyParser.json({ limit: '50mb' }));
  app.use(bodyParser.urlencoded({ limit: '50mb', extended: true }));

  await app.listen(envService.get('PORT'));

  // log misc stuff
  const apiUrl: string = await app.getUrl();
  logger.verbose(`GorillaVault api listening on --- ${apiUrl}`);
});

//? kid is id for searching secrets of token (only needed for other types of tokens like /some/secret.pem)

// crypto.randomBytes(64).toString("hex");

//TODO implement this in refresh token table
//TODO remove email from payload store it in database and validate it by fetching it
//TODO so first validate just token to decode it
//TODO then fetch from database refresh token repository
//TODO validate all registered claims

// save this stuff -> jti - new uuid(), user

//? existing
// id
// userId
// value

// createdAt

//? modify value -> token

//? add this as well
// sub - users email
// iss - constant~
// aud - web, mob (custom enum)
// exp -
// jti - new uuid (only for refresh token)
// is_used
// secret_encrypted

// 1. Extract the JTI value from the access token's payload.

// 2. Query your token tracking table or storage mechanism to check if the JTI exists and if it has been previously used.

// 3. If the JTI is found and marked as used, you can reject the token as invalid, as it indicates that the token has already been invalidated or used.

// 4. If the JTI is not found or is marked as unused, you can proceed with further validation steps, such as verifying the token signature, expiration, issuer, and other relevant claims.

// The JTI (JWT ID) claim is a unique identifier for a JSON Web Token (JWT). It is typically
// used to prevent token replay attacks by ensuring that a token is only used once. The JTI
// value is generated by the token issuer and should be unique for each issued token.

// Regarding the storage of JTI values, it is common to store them in a database table
// specifically designed to track and manage JWTs. This table can be created as part of your
// application's data schema and would typically include the following columns:

// 1. JTI: This column stores the JTI value, which is a unique identifier for each JWT.

// 2. Issued By: This column stores the issuer's identifier, allowing you to identify which entity issued the JWT.

// 3. Issued At: This column stores the timestamp indicating when the token was issued. It helps
// in determining the token's validity and expiration.

// 4. Expiration: This column stores the timestamp indicating when the token expires. It helps in
// determining whether a token is still valid or has expired.

// 5. Other Relevant Data: Depending on your application's requirements, you may include additional
// columns to store any other relevant data associated with the JWT, such as the user ID, client ID, or scope.

// When a JWT is issued, you would insert a new record into this table, storing the JTI, issuer,
// issuance timestamp, expiration timestamp, and any other relevant data. During token validation,
// you would query this table to check if the JTI exists and whether it has been used previously.
// If a JTI is found and marked as used, it indicates that the token has already been invalidated
// or used, helping prevent replay attacks.

// It's worth noting that the specific implementation and table structure can vary depending on your
// application's design and requirements. The table schema outlined above provides a general guideline,
// but you may need to adapt it based on your unique needs.
